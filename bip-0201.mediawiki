<pre>
  BIP: 201
  Title: BOLT 1: Base Protocol
  Author: Christian Decker <decker.christian@gmail.com>
          Olaoluwa Osuntokun <laolu32@gmail.com>
          Rusty Russell <rusty@rustcorp.com.au>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0201
  Status: Draft
  Type: Standards Track
  Created: 2016-11-15
  License: CC-BY-4.0
</pre>

== Overview ==

This protocol assumes an underlying authenticated and ordered transport mechanism that takes care of framing individual messages. [[bip-0208.mediawiki|BOLT #8]] specifies the canonical transport layer used in Lightning, though it can be replaced by any transport that fulfills the above guarantees.

The default TCP port is 9735. This corresponds to hexadecimal <code>0x2607</code>, the Unicode code point for LIGHTNING.<sup>[[#reference-1|1]]</sup>

All data fields are big-endian unless otherwise specified.

== Table of Contents ==

* [[#connection-handling-and-multiplexing|Connection handling and multiplexing]]
* [[#lightning-message-format|Lightning Message Format]]
* [[#setup-messages|Setup Messages]]
** [[#the-init-message|The <code>init</code> message]]
** [[#the-error-message|The <code>error</code> message]]
* [[#control-messages|Control Messages]]
** [[#the-ping-and-pong-messages|The <code>ping</code> and <code>pong</code> messages]]
* [[#acknowledgments|Acknowledgments]]
* [[#references|References]]
* [[#authors|Authors]]

== Connection handling and multiplexing ==

Implementations MUST use one connection per peer, channel messages (which include a channel id) being multiplexed over this single connection.

== Lightning Message Format ==

After decryption, all lightning messages are of the form:

# <code>type</code>: 2 byte big-endian field indicating the type of the message.
# <code>payload</code>: variable length payload. It comprises the remainder of the message and conforms to the format matching the <code>type</code>.

The <code>type</code> field indicates how to interpret the <code>payload</code> field. The format for each individual type is specified in a specification in this repository. The type follows the ''it's ok to be odd'' rule, so nodes MAY send odd-numbered types without ascertaining that the recipient understands it. A node MUST NOT send an evenly-typed message not listed here without prior negotiation. A node MUST ignore a received message of unknown type, if that type is odd. A node MUST fail the channels if it receives a message of unknown type, if that type is even.

The messages are grouped logically into 4 groups by their most significant set bit:

* Setup &amp; Control (types <code>0</code>-<code>31</code>): messages related to connection setup, control, supported features, and error reporting. These are described below.
* Channel (types <code>32</code>-<code>127</code>): comprises messages used to setup and tear down micropayment channels. These are described in [[bip-0202.mediawiki|BOLT #2]].
* Commitment (types <code>128</code>-<code>255</code>): comprises messages related to updating the current commitment transaction, which includes adding, revoking, and settling HTLCs, as well as updating fees and exchanging signatures. These are described in [[bip-0202.mediawiki|BOLT #2]].
* Routing (types <code>256</code>-<code>511</code>): node and channel announcements, as well as any active route exploration. These are described in [[bip-0207.mediawiki|BOLT #7]].

The size of the message is required to fit into a 2 byte unsigned int by the transport layer, therefore the maximum possible size is 65535 bytes. A node MUST ignore any additional data within a message, beyond the length it expects for that type. A node MUST fail the channels if it receives a known message with insufficient length for the contents.

=== Rationale ===

The standard endian of <code>SHA2</code> and the encoding of Bitcoin public keys are big endian, thus it would be unusual to use a different endian for other fields.

Length is limited to 65535 bytes by the cryptographic wrapping, and messages in the protocol are never more than that length anyway.

The &quot;it's OK to be odd&quot; rule allows for future optional extensions without negotiation or special coding in clients. The &quot;ignore additional data&quot; rule similarly allows for future expansion.

Implementations may prefer to have message data aligned on an 8 byte boundary (the largest natural alignment requirement of any type here), but adding a 6 byte padding after the type field was considered wasteful: alignment may be achieved by decrypting the message into a buffer with 6 bytes of pre-padding.

== Setup Messages ==

=== The <code>init</code> message ===

Once authentication is complete, the first message reveals the features supported or required by this node, even if this is a reconnection.

[[bip-0209.mediawiki|BOLT #9]] specifies lists of global and local features. Each feature is generally represented in <code>globalfeatures</code> or <code>localfeatures</code> by 2 bits. The least-significant bit is numbered 0, which is even, and the next most significant bit is numbered 1, which is odd.

Both fields <code>globalfeatures</code> and <code>localfeatures</code> MUST be padded to bytes with zeros.

# type: 16 (<code>init</code>)
# data:

* [<code>2</code>:<code>gflen</code>]
* [<code>gflen</code>:<code>globalfeatures</code>]
* [<code>2</code>:<code>lflen</code>]
* [<code>lflen</code>:<code>localfeatures</code>]

The 2 byte <code>gflen</code> and <code>lflen</code> fields indicate the number of bytes in the immediately following field.

==== Requirements ====

Each node MUST send <code>init</code> as the first lightning message for any connection. The sending node SHOULD use the minimum lengths required to represent the feature fields.

The sender MUST set feature bits as defined in [[bip-0209.mediawiki|BOLT #9]], and MUST set to zero any feature bits that are not defined.

The receiver MUST respond to known feature bits as specified in [[bip-0209.mediawiki|BOLT #9]]. For unknown feature bits which are non-zero, the receiver MUST ignore the bit if the bit number is odd, and MUST fail the connection if the bit number is even.

Each node MUST wait to receive <code>init</code> before sending any other messages.

==== Rationale ====

This semantic allows future incompatible changes, or backward compatible changes. Bits should generally be assigned in pairs, so that optional features can later become compulsory.

Nodes wait for receipt of the other's features to simplify error diagnosis where features are incompatible.

The feature masks are split into local features which only affect the protocol between these two nodes, and global features which can affect HTLCs and thus are also advertised to other nodes.

=== The <code>error</code> message ===

For simplicity of diagnosis, it is often useful to tell the peer that something is incorrect.

# type: 17 (<code>error</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>2</code>:<code>len</code>]
* [<code>len</code>:<code>data</code>]

The 2-byte <code>len</code> field indicates the number of bytes in the immediately following field.

==== Requirements ====

The channel is referred to by <code>channel_id</code> unless <code>channel_id</code> is zero (ie. all bytes zero), in which case it refers to all channels.

The funding node MUST use <code>temporary_channel_id</code> in lieu of <code>channel_id</code> for all error messages sent before (and including) the <code>funding_created</code> message. The fundee node MUST use <code>temporary_channel_id</code> in lieu of <code>channel_id</code> for all error messages sent before (and not including) the <code>funding_signed</code> message.

A node SHOULD send <code>error</code> for protocol violations or internal errors which make channels unusable or further communication unusable. A node MAY send an empty <code>data</code> field. A node sending <code>error</code> MUST fail the channel referred to by the error message, or if <code>channel_id</code> is zero, it MUST fail all channels and MUST close the connection. A node MUST set <code>len</code> equal to the length of <code>data</code>. A node SHOULD include the raw, hex-encoded transaction in reply to a <code>funding_created</code>, <code>funding_signed</code>, <code>closing_signed</code> or <code>commitment_signed</code> message when failure was caused by an invalid signature check.

A node receiving <code>error</code> MUST fail the channel referred to by the message, or if <code>channel_id</code> is zero, it MUST fail all channels and MUST close the connection. If no existing channel is referred to by the message, the receiver MUST ignore the message. A receiving node MUST truncate <code>len</code> to the remainder of the packet if it is larger.

A receiving node SHOULD only print out <code>data</code> verbatim if the string is composed solely of printable ASCII characters. For reference, the printable character set includes byte values 32 through 127 inclusive.

==== Rationale ====

There are unrecoverable errors which require an abort of conversations; if the connection is simply dropped then the peer may retry the connection. It's also useful to describe protocol violations for diagnosis, as it indicates that one peer has a bug.

It may be wise not to distinguish errors in production settings, lest it leak information, thus the optional <code>data</code> field.

== Control Messages ==

=== The <code>ping</code> and <code>pong</code> messages ===

In order to allow for the existence of very long-lived TCP connections, at times it may be required that both ends keep alive the TCP connection at the application level. Such messages also allow obfuscation of traffic patterns.

# type: 18 (<code>ping</code>)
# data:
#* [<code>2</code>:<code>num_pong_bytes</code>]
#* [<code>2</code>:<code>byteslen</code>]
#* [<code>byteslen</code>:<code>ignored</code>]

The <code>pong</code> message is to be sent whenever a <code>ping</code> message is received. It serves as a reply, and also serves to keep the connection alive while explicitly notifying the other end that the receiver is still active. Within the received <code>ping</code> message, the sender will specify the number of bytes to be included within the data payload of the <code>pong</code> message

# type: 19 (<code>pong</code>)
# data:
#* [<code>2</code>:<code>byteslen</code>]
#* [<code>byteslen</code>:<code>ignored</code>]

==== Requirements ====

A node sending <code>pong</code> or <code>ping</code> SHOULD set <code>ignored</code> to zeroes, but MUST NOT set <code>ignored</code> to sensitive data such as secrets, or portions of initialized memory.

A node SHOULD NOT send <code>ping</code> messages more often than once every 30 seconds, and MAY terminate the network connection if it does not receive a corresponding <code>pong</code>: it MUST NOT fail the channels in this case.

A node receiving a <code>ping</code> message SHOULD fail the channels if it has received significantly in excess of one <code>ping</code> per 30 seconds, otherwise if <code>num_pong_bytes</code> is less than 65532 it MUST respond by sending a <code>pong</code> message with <code>byteslen</code> equal to <code>num_pong_bytes</code>, otherwise it MUST ignore the <code>ping</code>.

A node receiving a <code>pong</code> message MAY fail the channels if <code>byteslen</code> does not correspond to any <code>ping</code> <code>num_pong_bytes</code> value it has sent.

=== Rationale ===

The largest possible message is 65535 bytes, thus maximum sensible <code>byteslen</code> is 65531 to account for the type field (<code>pong</code>) and <code>byteslen</code> itself. This gives us a convenient cutoff for <code>num_pong_bytes</code> to indicate that no reply should be sent.

Connections between nodes within the network may be very long lived as payment channels have an indefinite lifetime. However, it's likely that for a significant portion of the life-time of a connection, no new data will be exchanged. Additionally, on several platforms it's possible that Lightning clients will be put to sleep without prior warning. As a result, we use a distinct ping message in order to probe for the liveness of the connection on the other side, and also to keep the established connection active.

Additionally, the ability for a sender to request that the receiver send a response with a particular number of bytes enables nodes on the network to create ''synthetic'' traffic. Such traffic can be used to partially defend against packet and timing analysis as nodes can fake the traffic patterns of typical exchanges, without applying any true updates to their respective channels.

When combined with the onion routing protocol defined in [[bip-0204.mediawiki|BOLT #4]], careful statistically driven synthetic traffic can serve to further bolster the privacy of participants within the network.

Limited precautions are recommended against <code>ping</code> flooding, however some latitude is given because of network delays. Note that there are other methods of incoming traffic flooding (eg. sending odd unknown message types, or padding every message maximally).

Finally, the usage of periodic <code>ping</code> messages serves to promote frequent key rotations as specified within [[bip-0208.mediawiki|BOLT #8]].

== Acknowledgments ==

TODO(roasbeef); fin

== References ==

# <a id="reference-2">http://www.unicode.org/charts/PDF/U2600.pdf</a>

== Authors ==

FIXME

[[File:https://i.creativecommons.org/l/by/4.0/88x31.png|License CC-BY]] <br> This work is licensed under a [http://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution 4.0 International License].

