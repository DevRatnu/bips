<pre>
  BIP: 202
  Title: BOLT 2: Peer Protocol for Channel Management
  Author: Rusty Russell <rusty@rustcorp.com.au>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0202
  Status: Draft
  Type: Standards Track
  Created: 2016-11-15
  License: CC-BY-4.0
</pre>

The peer channel protocol has three phases: establishment, normal operation, and closing.

= Table of Contents =

* [[#channel|Channel]]
** [[#channel-establishment|Channel Establishment]]
** [[#the-open_channel-message|The <code>open_channel</code> message]]
** [[#the-accept_channel-message|The <code>accept_channel</code> message]]
** [[#the-funding_created-message|The <code>funding_created</code> message]]
** [[#the-funding_signed-message|The <code>funding_signed</code> message]]
** [[#the-funding_locked-message|The <code>funding_locked</code> message]]
** [[#channel-close|Channel Close]]
** [[#closing-initiation-shutdown|Closing initiation: <code>shutdown</code>]]
** [[#closing-negotiation-closing_signed|Closing negotiation: <code>closing_signed</code>]]
** [[#normal-operation|Normal Operation]]
** [[#forwarding-htlcs|Forwarding HTLCs]]
** [[#risks-with-htlc-timeouts|Risks With HTLC Timeouts]]
** [[#adding-an-htlc-update_add_htlc|Adding an HTLC: <code>update_add_htlc</code>]]
** [[#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc|Removing an HTLC: <code>update_fulfill_htlc</code>, <code>update_fail_htlc</code> and <code>update_fail_malformed_htlc</code>]]
** [[#committing-updates-so-far-commitment_signed|Committing Updates So Far: <code>commitment_signed</code>]]
** [[#completing-the-transition-to-the-updated-state-revoke_and_ack|Completing the transition to the updated state: <code>revoke_and_ack</code>]]
** [[#updating-fees-update_fee|Updating Fees: <code>update_fee</code>]]
** [[#message-retransmission|Message Retransmission]]
* [[#authors|Authors]]

= Channel =

== Channel Establishment ==

Channel establishment begins immediately after authentication, and consists of the funding node sending an <code>open_channel</code> message, followed by the responding node sending <code>accept_channel</code>. With the channel parameters locked in, the funder is able to create the funding transaction and both versions of the commitment transaction as described in [[bip-0203.mediawiki#bolt-3-bitcoin-transaction-and-script-formats|BOLT 03]]. The funder then sends the outpoint of the funding output along with a signature for the responder's version of the commitment transaction with the <code>funding_created</code> message. Once the responder learns the funding outpoint, she is able to generate the initiator's commitment for the commitment transaction, and send it over using the <code>funding_signed</code> message.

Once the channel funder receives the <code>funding_signed</code> message, they must broadcast the funding transaction to the Bitcoin network. After the <code>funding_signed</code> message is sent/received, both sides should wait for the funding transaction to enter the blockchain and reach their specified depth (number of confirmations). After both sides have sent the <code>funding_locked</code> message, the channel is established and can begin normal operation. The <code>funding_locked</code> message includes information which will be used to construct channel authentication proofs.

<pre>    +-------+                              +-------+
    |       |--(1)---  open_channel  -----&gt;|       |
    |       |&lt;-(2)--  accept_channel  -----|       |
    |       |                              |       |
    |   A   |--(3)--  funding_created  ---&gt;|   B   |
    |       |&lt;-(4)--  funding_signed  -----|       |
    |       |                              |       |
    |       |--(5)--- funding_locked  ----&gt;|       |
    |       |&lt;-(6)--- funding_locked  -----|       |
    +-------+                              +-------+</pre>
If this fails at any stage, or a node decides that the channel terms offered by the other node are not suitable, the channel establishment fails.

Note that multiple channels can operate in parallel, as all channel messages are identified by either a <code>temporary_channel_id</code> (before the funding transaction is created) or <code>channel_id</code> derived from the funding transaction.

=== The <code>open_channel</code> message ===

This message contains information about a node, and indicates its desire to set up a new channel.

# type: 32 (<code>open_channel</code>)
# data:

* [<code>32</code>:<code>chain_hash</code>]
* [<code>32</code>:<code>temporary_channel_id</code>]
* [<code>8</code>:<code>funding_satoshis</code>]
* [<code>8</code>:<code>push_msat</code>]
* [<code>8</code>:<code>dust_limit_satoshis</code>]
* [<code>8</code>:<code>max_htlc_value_in_flight_msat</code>]
* [<code>8</code>:<code>channel_reserve_satoshis</code>]
* [<code>8</code>:<code>htlc_minimum_msat</code>]
* [<code>4</code>:<code>feerate_per_kw</code>]
* [<code>2</code>:<code>to_self_delay</code>]
* [<code>2</code>:<code>max_accepted_htlcs</code>]
* [<code>33</code>:<code>funding_pubkey</code>]
* [<code>33</code>:<code>revocation_basepoint</code>]
* [<code>33</code>:<code>payment_basepoint</code>]
* [<code>33</code>:<code>delayed_payment_basepoint</code>]
* [<code>33</code>:<code>first_per_commitment_point</code>]
* [<code>1</code>:<code>channel_flags</code>]

The <code>chain_hash</code> value denotes the exact blockchain the opened channel will reside within. This is usually the genesis hash of the respective blockchain. The existence of the <code>chain_hash</code> allows nodes to open channel across many distinct blockchains as well as have channels within multiple blockchains opened to the same peer (if they support the target chains).

The <code>temporary_channel_id</code> is used to identify this channel until the funding transaction is established. <code>funding_satoshis</code> is the amount the sender is putting into the channel. <code>dust_limit_satoshis</code> is the threshold below which output should be generated for this node's commitment or HTLC transaction; ie. HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain. This reflects the reality that tiny outputs are not considered standard transactions and will not propagate through the Bitcoin network.

<code>max_htlc_value_in_flight_msat</code> is a cap on total value of outstanding HTLCs, which allows a node to limit its exposure to HTLCs; similarly <code>max_accepted_htlcs</code> limits the number of outstanding HTLCs the other node can offer. <code>channel_reserve_satoshis</code> is the minimum amount that the other node is to keep as a direct payment. <code>htlc_minimum_msat</code> indicates the smallest value HTLC this node will accept.

<code>feerate_per_kw</code> indicates the initial fee rate by 1000-weight (ie. 1/4 the more normally-used 'feerate per kilobyte') which this side will pay for commitment and HTLC transactions as described in [[bip-0203.mediawiki#fee-calculation|BOLT #3]] (this can be adjusted later with an <code>update_fee</code> message). <code>to_self_delay</code> is the number of blocks that the other nodes to-self outputs must be delayed, using <code>OP_CHECKSEQUENCEVERIFY</code> delays; this is how long it will have to wait in case of breakdown before redeeming its own funds.

Only the least-significant bit of <code>channel_flags</code> is currently defined: <code>announce_channel</code>. This indicates whether the initiator of the funding flow wishes to advertise this channel publicly to the network as detailed within [[bip-0207.mediawiki#bolt-7-p2p-node-and-channel-discovery|BOLT #7]].

The <code>funding_pubkey</code> is the public key in the 2-of-2 multisig script of the funding transaction output. The <code>revocation_basepoint</code> is combined with the revocation preimage for this commitment transaction to generate a unique revocation key for this commitment transaction. The <code>payment_basepoint</code> and <code>delayed_payment_basepoint</code> are similarly used to generate a series of keys for any payments to this node: <code>delayed_payment_basepoint</code> is used to for payments encumbered by a delay. Varying these keys ensures that the transaction ID of each commitment transaction is unpredictable by an external observer, even if one commitment transaction is seen: this property is very useful for preserving privacy when outsourcing penalty transactions to third parties.

FIXME: Describe Dangerous feature bit for larger channel amounts.

==== Requirements ====

A sending node MUST ensure that the <code>chain_hash</code> value identifies the chain they they wish to open the channel within. For the Bitcoin blockchain, the <code>chain_hash</code> value MUST be (encoded in hex): <code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>.

A sending node MUST ensure <code>temporary_channel_id</code> is unique from any other channel id with the same peer. The sender MUST set <code>funding_satoshis</code> to less than 2^24 satoshi. The sender MUST set <code>push_msat</code> to equal or less than to 1000 * <code>funding_satoshis</code>. The sender SHOULD set <code>to_self_delay</code> sufficient to ensure the sender can irreversibly spend a commitment transaction output in case of misbehavior by the receiver. <code>funding_pubkey</code>, <code>revocation_basepoint</code>, <code>payment_basepoint</code> and <code>delayed_payment_basepoint</code> MUST be valid DER-encoded compressed secp256k1 pubkeys. The sender SHOULD set <code>feerate_per_kw</code> to at least the rate it estimates would cause the transaction to be immediately included in a block.

The sender SHOULD set <code>dust_limit_satoshis</code> to a sufficient value to allow commitment transactions to propagate through the Bitcoin network. It SHOULD set <code>htlc_minimum_msat</code> to the minimum amount HTLC it is willing to accept from this peer.

The receiving node MAY fail the channel if <code>announce_channel</code> is <code>false</code> (<code>0</code>), yet they wish to publicly announce the channel. The receiving node MUST ignore undefined bits in <code>channel_flags</code>.

The receiving node MUST accept a new <code>open_channel</code> message if the connection has been re-established after receiving a previous <code>open_channel</code> and before receiving a <code>funding_created</code> message. In this case, the receiving node MUST discard the previous <code>open_channel</code> message.

The receiving node MUST fail the channel if <code>to_self_delay</code> is unreasonably large. The receiver MAY fail the channel if <code>funding_satoshis</code> is too small, and MUST fail the channel if <code>push_msat</code> is greater than <code>funding_satoshis</code> * 1000. The receiving node MAY fail the channel if it considers <code>htlc_minimum_msat</code> too large, <code>max_htlc_value_in_flight_msat</code> too small, <code>channel_reserve_satoshis</code> too large, or <code>max_accepted_htlcs</code> too small. It MUST fail the channel if <code>max_accepted_htlcs</code> is greater than 483.

The receiver MUST fail the channel if it considers <code>feerate_per_kw</code> too small for timely processing, or unreasonably large. The receiver MUST fail the channel if <code>funding_pubkey</code>, <code>revocation_basepoint</code>, <code>payment_basepoint</code> or <code>delayed_payment_basepoint</code> are not valid DER-encoded compressed secp256k1 pubkeys.

The receiver MUST NOT consider funds received using <code>push_msat</code> to be received until the funding transaction has reached sufficient depth.

==== Rationale ====

The ''channel reserve'' is specified by the peer's <code>channel_reserve_satoshis</code>; 1% of the channel total is suggested. Each side of a channel maintains this reserve so it always has something to lose if it were to try to broadcast an old, revoked commitment transaction. Initially this reserve may not be met, as only one side has funds, but the protocol ensures that progress is always toward it being met, and once met it is maintained.

The sender can unconditionally give initial funds to the receiver using a non-zero <code>push_msat</code>, and this is one case where the normal reserve mechanism doesn't apply. However, like any other on-chain transaction, this payment is not certain until the funding transaction has been confirmed sufficiently (may be double-spent) and may require a separate method to prove payment via on-chain confirmation.

The <code>feerate_per_kw</code> is generally only a concern to the sender (who pays the fees), but that is also the feerate paid by HTLC transactions; thus unreasonably large fee rates can also penalize the recipient.

==== Future ====

It would be easy to have a local feature bit which indicated that a receiving node was prepared to fund a channel, which would reverse this protocol.

=== The <code>accept_channel</code> message ===

This message contains information about a node, and indicates its acceptance of the new channel.

# type: 33 (<code>accept_channel</code>)
# data:

* [<code>32</code>:<code>temporary_channel_id</code>]
* [<code>8</code>:<code>dust_limit_satoshis</code>]
* [<code>8</code>:<code>max_htlc_value_in_flight_msat</code>]
* [<code>8</code>:<code>channel_reserve_satoshis</code>]
* [<code>8</code>:<code>htlc_minimum_msat</code>]
* [<code>4</code>:<code>minimum_depth</code>]
* [<code>2</code>:<code>to_self_delay</code>]
* [<code>2</code>:<code>max_accepted_htlcs</code>]
* [<code>33</code>:<code>funding_pubkey</code>]
* [<code>33</code>:<code>revocation_basepoint</code>]
* [<code>33</code>:<code>payment_basepoint</code>]
* [<code>33</code>:<code>delayed_payment_basepoint</code>]
* [<code>33</code>:<code>first_per_commitment_point</code>]

==== Requirements ====

The receiving MUST reject the channel if the <code>chain_hash</code> value within the <code>open_channel</code> message is set to a hash of a chain unknown to the receiver.

The <code>temporary_channel_id</code> MUST be the same as the <code>temporary_channel_id</code> in the <code>open_channel</code> message. The sender SHOULD set <code>minimum_depth</code> to a number of blocks it considers reasonable to avoid double-spending of the funding transaction.

The receiver MAY reject the <code>minimum_depth</code> if it considers it unreasonably large. Other fields have the same requirements as their counterparts in <code>open_channel</code>.

=== The <code>funding_created</code> message ===

This message describes the outpoint which the funder has created for the initial commitment transactions. After receiving the peer's signature, it will broadcast the funding transaction.

# type: 34 (<code>funding_created</code>)
# data:
#* [<code>32</code>:<code>temporary_channel_id</code>]
#* [<code>32</code>:<code>funding_txid</code>]
#* [<code>2</code>:<code>funding_output_index</code>]
#* [<code>64</code>:<code>signature</code>]

==== Requirements ====

The sender MUST set <code>temporary_channel_id</code> the same as the <code>temporary_channel_id</code> in the <code>open_channel</code> message. The sender MUST set <code>funding_txid</code> to the transaction ID of a non-malleable transaction, which it MUST NOT broadcast, and MUST set <code>funding_output_index</code> to the output number of that transaction which corresponds the funding transaction output as defined in [[bip-0203.mediawiki#funding-transaction-output|BOLT #3]], and MUST set <code>signature</code> to the valid signature using its <code>funding_pubkey</code> for the initial commitment transaction as defined in [[bip-0203.mediawiki#commitment-transaction|BOLT #3]]. The sender SHOULD use only BIP141 (Segregated Witness) inputs when creating the funding transaction.

The recipient MUST fail the channel if <code>signature</code> is incorrect.

==== Rationale ====

The <code>funding_output_index</code> can only be 2 bytes, since that's how we'll pack it into the <code>channel_id</code> used throughout the gossip protocol. The limit of 65535 outputs should not be overly burdensome.

A transaction with all Segregated Witness inputs is not malleable, hence the recommendation for the funding transaction.

=== The <code>funding_signed</code> message ===

This message gives the funder the signature they need for the first commitment transaction, so they can broadcast it knowing they can redeem their funds if they need to.

This message introduces the <code>channel_id</code> to identify the channel, which is derived from the funding transaction by combining the <code>funding_txid</code> and the <code>funding_output_index</code> using big-endian exclusive-OR (ie. <code>funding_output_index</code> alters the last two bytes).

# type: 35 (<code>funding_signed</code>)
# data:
#* [<code>32</code>:<code>channel_id</code>]
#* [<code>64</code>:<code>signature</code>]

==== Requirements ====

The sender MUST set <code>channel_id</code> by exclusive-OR of the <code>funding_txid</code> and the <code>funding_output_index</code> from the <code>funding_created</code> message, and MUST set <code>signature</code> to the valid signature using its <code>funding_pubkey</code> for the initial commitment transaction as defined in [[bip-0203.mediawiki#commitment-transaction|BOLT #3]].

The recipient MUST fail the channel if <code>signature</code> is incorrect.

The recipient SHOULD broadcast the funding transaction on receipt of a valid <code>funding_signed</code> and MUST NOT broadcast the funding transaction earlier.

=== The <code>funding_locked</code> message ===

This message indicates that the funding transaction has reached the <code>minimum_depth</code> asked for in <code>accept_channel</code>. Once both nodes have sent this, the channel enters normal operating mode.

# type: 36 (<code>funding_locked</code>)
# data:
#* [<code>32</code>:<code>channel_id</code>]
#* [<code>33</code>:<code>next_per_commitment_point</code>]

==== Requirements ====

The sender MUST wait until the funding transaction has reached <code>minimum_depth</code> before sending this message.

The sender MUST set <code>next_per_commitment_point</code> to the per-commitment point to be used for the following commitment transaction, derived as specified in [[bip-0203.mediawiki#per-commitment-secret-requirements|BOLT #3]].

A non-funding node SHOULD forget the channel if it does not see the funding transaction after a reasonable timeout.

From the point of waiting for <code>funding_locked</code> onward, a node MAY fail the channel if it does not receive a required response from the other node after a reasonable timeout.

==== Rationale ====

The non-funder can simply forget the channel ever existed, since no funds are at risk; even if <code>push_msat</code> is significant, if it remembers the channel forever on the promise of the funding transaction finally appearing, there is a denial of service risk.

==== Future ====

We could add an SPV proof, and route block hashes in separate messages.

== Channel Close ==

Nodes can negotiate a mutual close for the connection, which unlike a unilateral close, allows them to access their funds immediately and can be negotiated with lower fees.

Closing happens in two stages: the first is by one side indicating that it wants to clear the channel (and thus will accept no new HTLCs), and once all HTLCs are resolved, the final channel close negotiation begins.

<pre>    +-------+                              +-------+
    |       |--(1)-----  shutdown  -------&gt;|       |
    |       |&lt;-(2)-----  shutdown  --------|       |
    |       |                              |       |
    |       | &lt;complete all pending HTLCs&gt; |       |
    |   A   |                 ...          |   B   |
    |       |                              |       |
    |       |&lt;-(3)-- closing_signed  F1----|       |
    |       |--(4)-- closing_signed  F2---&gt;|       |
    |       |              ...             |       |
    |       |--(?)-- closing_signed  Fn---&gt;|       |
    |       |&lt;-(?)-- closing_signed  Fn----|       |
    +-------+                              +-------+</pre>
=== Closing initiation: <code>shutdown</code> ===

Either node (or both) can send a <code>shutdown</code> message to initiate closing, and indicating the scriptpubkey it wants to be paid to.

# type: 38 (<code>shutdown</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>2</code>:<code>len</code>]
* [<code>len</code>:<code>scriptpubkey</code>]

==== Requirements ====

A node MUST NOT send a <code>shutdown</code> if there are updates pending on the receiving node's commitment transaction.

A node MUST NOT send an <code>update_add_htlc</code> after a <code>shutdown</code>. A sending node SHOULD fail to route any HTLC added after it sent <code>shutdown</code>.

A sending node MUST set <code>scriptpubkey</code> to one of the following forms:

# <code>OP_DUP</code> <code>OP_HASH160</code> <code>20</code> 20-bytes <code>OP_EQUALVERIFY</code> <code>OP_CHECKSIG</code> (pay to pubkey hash), OR
# <code>OP_HASH160</code> <code>20</code> 20-bytes <code>OP_EQUAL</code> (pay to script hash), OR
# <code>OP_0</code> <code>20</code> 20-bytes (version 0 pay to witness pubkey), OR
# <code>OP_0</code> <code>32</code> 32-bytes (version 0 pay to witness script hash)

A receiving node SHOULD fail the connection if the <code>scriptpubkey</code> is not one of those forms.

A receiving node MUST reply to a <code>shutdown</code> message with a <code>shutdown</code> once there are no outstanding updates on the peer, unless it has already sent a <code>shutdown</code>.

==== Rationale ====

If channel state is always &quot;clean&quot; (no pending changes) when a shutdown starts, we avoid the question of how to behave if it wasn't; the sender always send an <code>commitment_signed</code> first.

As shutdown implies a desire to terminate, it implies that no new HTLCs will be added or accepted.

The <code>scriptpubkey</code> forms include only standard forms accepted by the Bitcoin network, ensuring that the resulting transaction will propagate to miners.

The <code>shutdown</code> response requirement implies that the node sends <code>commitment_signed</code> to commit any outstanding changes before replying, but it could theoretically reconnect instead, which simply erases all outstanding uncommitted changes.

=== Closing negotiation: <code>closing_signed</code> ===

Once shutdown is complete and the channel is empty of HTLCs, the final current commitment transactions will have no HTLCs, and closing fee negotiation begins. Each node chooses a fee it thinks is fair, and signs the close transaction with the <code>scriptpubkey</code> fields from the <code>shutdown</code> messages and that fee, and sends the signature. The process terminates when both agree on the same fee, or one side fails the channel.

# type: 39 (<code>closing_signed</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>8</code>:<code>fee_satoshis</code>]
* [<code>64</code>:<code>signature</code>]

==== Requirements ====

Nodes SHOULD send a <code>closing_signed</code> message after <code>shutdown</code> has been received and no HTLCs remain in either commitment transaction.

A sending node MUST set <code>fee_satoshis</code> lower than or equal to the fee of the final commitment transaction.

The sender SHOULD set the initial <code>fee_satoshis</code> according to its estimate of cost of inclusion in a block.

The sender MUST set <code>signature</code> to the Bitcoin signature of the close transaction with the node responsible for paying the bitcoin fee paying <code>fee_satoshis</code>, without populating any output which is below its own <code>dust_limit_satoshis</code>. The sender MAY also eliminate its own output from the mutual close transaction.

The receiver MUST check <code>signature</code> is valid for either the close transaction with the given <code>fee_satoshis</code> as detailed above and its own <code>dust_limit_satoshis</code> OR that same transaction with the sender's output eliminated, and MUST fail the connection if it is not.

If the receiver agrees with the fee, it SHOULD reply with a <code>closing_signed</code> with the same <code>fee_satoshis</code> value, otherwise it SHOULD propose a value strictly between the received <code>fee_satoshis</code> and its previously-sent <code>fee_satoshis</code>.

Once a node has sent or received a <code>closing_signed</code> with matching <code>fee_satoshis</code> it SHOULD close the connection and SHOULD sign and broadcast the final closing transaction.

==== Rationale ====

There is a possibility of irreparable differences on closing if one node considers the other's output too small to allow propagation on the bitcoin network (aka &quot;dust&quot;), and that other node instead considers that output to be too valuable to discard. This is why each side uses its own <code>dust_limit_satoshis</code>, and the result can be a signature validation failure, if they disagree on what the closing transaction should look like.

However, if one side chooses to eliminate its own output, there's no reason for the other side to fail the closing protocol, so this is explicitly allowed.

Note that there is limited risk if the closing transaction is delayed, and it will be broadcast very soon, so there is usually no reason to pay a premium for rapid processing.

== Normal Operation ==

Once both nodes have exchanged <code>funding_locked</code> (and optionally [[bip-0207.mediawiki#the-announcement_signatures-message|<code>announcement_signatures</code>]]), the channel can be used to make payments via Hash TimeLocked Contracts.

Changes are sent in batches: one or more <code>update_</code> messages are sent before a <code>commitment_signed</code> message, as in the following diagram:

<pre>    +-------+                            +-------+
    |       |--(1)---- add_htlc   ------&gt;|       |
    |       |--(2)---- add_htlc   ------&gt;|       |
    |       |&lt;-(3)---- add_htlc   -------|       |
    |       |                            |       |
    |       |--(4)----   commit   ------&gt;|       |
    |   A   |                            |   B   |
    |       |&lt;-(5)--- revoke_and_ack-----|       |
    |       |&lt;-(6)----   commit   -------|       |
    |       |                            |       |
    |       |--(7)--- revoke_and_ack----&gt;|       |
    +-------+                            +-------+</pre>
Counterintuitively, these updates apply to the ''other node's'' commitment transaction; the node only adds those updates to its own commitment transaction when the remote node acknowledges it has applied them via <code>revoke_and_ack</code>.

Thus each update traverses through the following states:

# Pending on the receiver
# In the receiver's latest commitment transaction,
# ... and the receiver's previous commitment transaction has been revoked, and the HTLC is pending on the sender.
# ... and in the sender's latest commitment transaction
# ... and the sender's previous commitment transaction has been revoked

As the two nodes updates are independent, the two commitment transactions may be out of sync indefinitely. This is not concerning: what matters is whether both sides have irrevocably committed to a particular HTLC or not (the final state, above).

=== Forwarding HTLCs ===

In general, a node offers HTLCs for two reasons: to initiate a payment of its own, or to forward a payment coming from another node. In the forwarding case, care must be taken to ensure that the ''outgoing'' HTLC cannot be redeemed unless the ''incoming'' HTLC can be redeemed; these requirements ensure that is always true.

The addition/removal of an HTLC is considered ''irrevocably committed'' when:

# the commitment transaction with/without it it is committed by both nodes, and any previous commitment transaction which without/with it has been revoked, OR
# the commitment transaction with/without it has been irreversibly committed to the blockchain.

==== Requirements ====

A node MUST NOT offer an HTLC (<code>update_add_htlc</code>) in response to an incoming HTLC until the incoming HTLC has been irrevocably committed.

A node MUST NOT fail an incoming HTLC (<code>update_fail_htlc</code>) for which it has committed to an outgoing HTLC, until the removal of the outgoing HTLC is irrevocably committed.

A node SHOULD fulfill an incoming HTLC for which it has committed to an outgoing HTLC, as soon as it receives <code>update_fulfill_htlc</code> for the outgoing HTLC.

==== Rationale ====

In general, we need to complete one side of the exchange before dealing with the other. Fulfilling an HTLC is different: knowledge of the preimage is by definition irrevocable, so we should fulfill the incoming HTLC as soon as we can to reduce latency.

=== Risks With HTLC Timeouts ===

Once an HTLC has timed out where it could either be fulfilled or timed-out; care must be taken around this transition both for offered and received HTLCs.

As a result of forwarding an HTLC from node A to node C, B will end up having an incoming HTLC from A and an outgoing HTLC to C. B will make sure that the incoming HTLC has a greater timeout than the outgoing HTLC, so that B can get refunded from C sooner than it has to refund A if the payment does not complete.

For example, node A might offer node B an HTLC with a timeout of 3 days, and node B might offer node C the same HTLC with a timeout of 2 days:

<pre>    3 days timeout        2 days timeout
A ------------------&gt; B ------------------&gt; C </pre>
The difference in timeouts is called <code>cltv_expiry_delta</code> in [[bip-0207.mediawiki|BOLT #7]].

This difference is important: after 2 days B can try to remove the offer to C even if C is unresponsive, by broadcasting the commitment transaction it has with C and spending the HTLC output. Even though C might race to try to use its payment preimage at that point to also spend the HTLC, it should be resolved well before the 3 day deadline so B can either redeem the HTLC off A or close it.

If the timing is too close, there is a risk of &quot;one-sided redemption&quot;, where the payment preimage received from an offered HTLC is too late to be used for an incoming HTLC, leaving the node with unexpected liability.

Thus the effective timeout of the HTLC is the <code>cltv_expiry</code>, plus some additional delay for the transaction which redeems the HTLC output to be irreversibly committed to the blockchain.

The fulfillment risk is similar: if a node C fulfills an HTLC after its timeout, B might broadcast the commitment transaction and immediately broadcast the HTLC timeout transaction. In this scenario, B would gain knowledge of the preimage without paying C.

==== Requirements ====

A node MUST estimate the deadline for successful redemption for each HTLC. A node MUST NOT offer a HTLC after this deadline, and MUST fail the channel if an HTLC which it offered is in either node's current commitment transaction past this deadline.

A node MUST NOT fulfill an HTLC after this deadline, and MUST fail the connection if a HTLC it has fulfilled is in either node's current commitment transaction past this deadline.

=== Adding an HTLC: <code>update_add_htlc</code> ===

Either node can send <code>update_add_htlc</code> to offer a HTLC to the other, which is redeemable in return for a payment preimage. Amounts are in millisatoshi, though on-chain enforcement is only possible for whole satoshi amounts greater than the dust limit: in commitment transactions these are rounded down as specified in [[bip-0203.mediawiki|BOLT #3]].

The format of the <code>onion_routing_packet</code> portion, which indicates where the payment is destined, is described in [[bip-0204.mediawiki|BOLT #4]].

# type: 128 (<code>update_add_htlc</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>8</code>:<code>id</code>]
* [<code>8</code>:<code>amount_msat</code>]
* [<code>32</code>:<code>payment_hash</code>]
* [<code>4</code>:<code>cltv_expiry</code>]
* [<code>1366</code>:<code>onion_routing_packet</code>]

==== Requirements ====

A sending node MUST NOT offer <code>amount_msat</code> it cannot pay for in the remote commitment transaction at the current <code>feerate_per_kw</code> (see &quot;Updating Fees&quot;) while maintaining its channel reserve, MUST offer <code>amount_msat</code> greater than 0, MUST NOT offer <code>amount_msat</code> below the receiving node's <code>htlc_minimum_msat</code>, and MUST set <code>cltv_expiry</code> less than 500000000.

For channels with <code>chain_hash</code> identifying the Bitcoin blockchain, the sending node MUST set the 4 most significant bytes of <code>amount_msat</code> to zero.

A sending node MUST NOT add an HTLC if it would result in it offering more than the remote's <code>max_accepted_htlcs</code> HTLCs in the remote commitment transaction, or if the sum of total offered HTLCs would exceed the remote's <code>max_htlc_value_in_flight_msat</code>.

A sending node MUST set <code>id</code> to 0 for the first HTLC it offers, and increase the value by 1 for each successive offer.

A receiving node SHOULD fail the channel if it receives an <code>amount_msat</code> equal to zero, below its own <code>htlc_minimum_msat</code>, or which the sending node cannot afford at the current <code>feerate_per_kw</code> while maintaining its channel reserve. A receiving node SHOULD fail the channel if a sending node adds more than its <code>max_accepted_htlcs</code> HTLCs to its local commitment transaction, or adds more than its <code>max_htlc_value_in_flight_msat</code> worth of offered HTLCs to its local commitment transaction, or sets <code>cltv_expiry</code> to greater or equal to 500000000.

For channels with <code>chain_hash</code> identifying the Bitcoin blockchain, the receiving node MUST fail the channel if the 4 most significant bytes of <code>amount_msat</code> are not zero.

A receiving node MUST allow multiple HTLCs with the same payment hash.

A receiving node MUST ignore a repeated <code>id</code> value after a reconnection if the sender did not previously acknowledge the commitment of that HTLC. A receiving node MAY fail the channel if other <code>id</code> violations occur.

The <code>onion_routing_packet</code> contains an obfuscated list of hops and instructions for each hop along the path. It commits to the HTLC by setting the <code>payment_hash</code> as associated data, i.e., including the <code>payment_hash</code> in the computation of HMACs. This prevents replay attacks that'd reuse a previous <code>onion_routing_packet</code> with a different <code>payment_hash</code>.

==== Rationale ====

Invalid amounts are a clear protocol violation and indicate a breakdown.

If a node did not accept multiple HTLCs with the same payment hash, an attacker could probe to see if a node had an existing HTLC. This requirement deal with duplicates leads us to using a separate identifier; we assume a 64 bit counter never wraps.

Retransmissions of unacknowledged updates are explicitly allowed for reconnection purposes; allowing them at other times simplifies the recipient code, though strict checking may help debugging.

<code>max_accepted_htlcs</code> is limited to 483, to ensure that even if both sides send the maximum number of HTLCs, the <code>commitment_signed</code> message will still be under the maximum message size. It also ensures that a single penalty transaction can spend the entire commitment transaction, as calculated in [[bip-0205.mediawiki#penalty-transaction-weight-calculation|BOLT #5]].

<code>cltv_expiry</code> values equal or above 500000000 would indicate a time in seconds, and the protocol only supports an expiry in blocks.

<code>amount_msat</code> is deliberately limited for this version of the specification; larger amounts are not necessary nor wise during the bootstrap phase of the network.

=== Removing an HTLC: <code>update_fulfill_htlc</code>, <code>update_fail_htlc</code> and <code>update_fail_malformed_htlc</code> ===

For simplicity, a node can only remove HTLCs added by the other node. There are three reasons for removing an HTLC: it has timed out, it has failed to route, or the payment preimage is supplied.

The <code>reason</code> field is an opaque encrypted blob for the benefit of the original HTLC initiator as defined in [[bip-0204.mediawiki|BOLT #4]], but there's a special malformed failure variant for the case where our peer couldn't parse it; in this case the current node encrypts it into a <code>update_fail_htlc</code> for relaying.

# type: 130 (<code>update_fulfill_htlc</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>8</code>:<code>id</code>]
* [<code>32</code>:<code>payment_preimage</code>]

For a timed out or route-failed HTLC:

# type: 131 (<code>update_fail_htlc</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>8</code>:<code>id</code>]
* [<code>2</code>:<code>len</code>]
* [<code>len</code>:<code>reason</code>]

For a unparsable HTLC:

# type: 135 (<code>update_fail_malformed_htlc</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>8</code>:<code>id</code>]
* [<code>32</code>:<code>sha256_of_onion</code>]
* [<code>2</code>:<code>failure_code</code>]

==== Requirements ====

A node SHOULD remove an HTLC as soon as it can; in particular, a node SHOULD fail an HTLC which has timed out.

A node MUST NOT send <code>update_fulfill_htlc</code> until an HTLC is irrevocably committed in both sides' commitment transactions.

A receiving node MUST check that <code>id</code> corresponds to an HTLC in its current commitment transaction, and MUST fail the channel if it does not.

A receiving node MUST check that the <code>payment_preimage</code> value in <code>update_fulfill_htlc</code> SHA256 hashes to the corresponding HTLC <code>payment_hash</code>, and MUST fail the channel if it does not.

A receiving node MUST fail the channel if the <code>BADONION</code> bit in <code>failure_code</code> is not set for <code>update_fail_malformed_htlc</code>.

A receiving node MAY check the <code>sha256_of_onion</code> in <code>update_fail_malformed_htlc</code> and MAY retry or choose an alternate error response if it does not match the onion it sent.

Otherwise, a receiving node which has an outgoing HTLC canceled by <code>update_fail_malformed_htlc</code> MUST return an error in the <code>update_fail_htlc</code> sent to the link which originally sent the HTLC using the <code>failure_code</code> given and setting the data to <code>sha256_of_onion</code>.

==== Rationale ====

A node which doesn't time out HTLCs risks channel failure (see &quot;Risks With HTLC Timeouts&quot;).

A node which sends <code>update_fulfill_htlc</code> before the sender is also committed to the HTLC risks losing funds.

If the onion is malformed, the upstream node won't be able to extract a key to generate a response, hence the special failure message which makes this node do it.

The node can check that the SHA256 the upstream is complaining about does match the onion it sent, which may allow it to detect random bit errors. Without re-checking the actual encrypted packet sent, however, it won't know whether the error was its own or on the remote side, so such detection is left as an option.

=== Committing Updates So Far: <code>commitment_signed</code> ===

When a node has changes for the remote commitment, it can apply them, sign the resulting transaction as defined in [[bip-0203.mediawiki|BOLT #3]] and send a <code>commitment_signed</code> message.

# type: 132 (<code>commitment_signed</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>64</code>:<code>signature</code>]
* [<code>2</code>:<code>num_htlcs</code>]
* [<code>num_htlcs*64</code>:<code>htlc_signature</code>]

==== Requirements ====

A node MUST NOT send a <code>commitment_signed</code> message which does not include any updates. Note that a node MAY send a <code>commitment_signed</code> message which only alters the fee, and MAY send a <code>commitment_signed</code> message which doesn't change the commitment transaction other than the new revocation hash (due to dust, identical HTLC replacement, or insignificant or multiple fee changes). A node MUST include one <code>htlc_signature</code> for every HTLC transaction corresponding to BIP69 lexicographic ordering of the commitment transaction.

A receiving node MUST fail the channel if <code>signature</code> is not valid for its local commitment transaction once all pending updates are applied. A receiving node MUST fail the channel if <code>num_htlcs</code> is not equal to the number of HTLC outputs in the local commitment transaction once all pending updates are applied. A receiving node MUST fail the channel if any <code>htlc_signature</code> is not valid for the corresponding HTLC transaction.

A receiving node MUST respond with a <code>revoke_and_ack</code> message.

==== Rationale ====

There's little point offering spam updates; it implies a bug.

The <code>num_htlcs</code> field is redundant, but makes the packet length check fully self-contained.

=== Completing the transition to the updated state: <code>revoke_and_ack</code> ===

Once the recipient of <code>commitment_signed</code> checks the signature, it knows that it has a valid new commitment transaction, replies with the commitment preimage for the previous commitment transaction in a <code>revoke_and_ack</code> message.

This message also implicitly serves as an acknowledgment of receipt of the <code>commitment_signed</code>, so it's a logical time for the <code>commitment_signed</code> sender to apply to its own commitment, any pending updates it sent before that <code>commitment_signed</code>.

The description of key derivation is in [[bip-0203.mediawiki#key-derivation|BOLT #3]].

# type: 133 (<code>revoke_and_ack</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>32</code>:<code>per_commitment_secret</code>]
* [<code>33</code>:<code>next_per_commitment_point</code>]

==== Requirements ====

A sending node MUST set <code>per_commitment_secret</code> to the secret used to generate keys for the previous commitment transaction, MUST set <code>next_per_commitment_point</code> to the values for its next commitment transaction.

A receiving node MUST check that <code>per_commitment_secret</code> generates the previous <code>per_commitment_point</code>, and MUST fail if it does not. A receiving node MAY fail if the <code>per_commitment_secret</code> was not generated by the protocol in [[bip-0203.mediawiki#per-commitment-secret-requirements|BOLT #3]].

Nodes MUST NOT broadcast old (revoked) commitment transactions; doing so will allow the other node to seize all the funds. Nodes SHOULD NOT sign commitment transactions unless it is about to broadcast them (due to a failed connection), to reduce this risk.

=== Updating Fees: <code>update_fee</code> ===

An <code>update_fee</code> message is sent by the node which is paying the bitcoin fee. Like any update, it is first committed to the receiver's commitment transaction, then (once acknowledged) committed to the sender's. Unlike an HTLC, <code>update_fee</code> is never closed, simply replaced.

There is a possibility of a race: the recipient can add new HTLCs before it receives the <code>update_fee</code>, and the sender may not be able to afford the fee on its own commitment transaction once the <code>update_fee</code> is acknowledged by the recipient. In this case, the fee will be less than the fee rate, as described in [[bip-0203.mediawiki#fee-payment|BOLT #3]].

The exact calculation used for deriving the fee from the fee rate is given in [[bip-0203.mediawiki#fee-calculation|BOLT #3]].

# type: 134 (<code>update_fee</code>)
# data:

* [<code>32</code>:<code>channel_id</code>]
* [<code>4</code>:<code>feerate_per_kw</code>]

==== Requirements ====

The node which is responsible for paying the bitcoin fee SHOULD send <code>update_fee</code> to ensure the current fee rate is sufficient for timely processing of the commitment transaction by a significant margin.

The node which is not responsible for paying the bitcoin fee MUST NOT send <code>update_fee</code>.

A receiving node SHOULD fail the channel if the <code>update_fee</code> is too low for timely processing, or unreasonably large.

A receiving node MUST fail the channel if the sender is not responsible for paying the bitcoin fee.

A receiving node SHOULD fail the channel if the sender cannot afford the new fee rate on the receiving node's current commitment transaction, but it MAY delay this check until the <code>update_fee</code> is committed.

==== Rationale ====

Bitcoin fees are required for unilateral closes to be effective, particularly since there is no general method for the node which broadcasts it to use child-pays-for-parent to increase its effective fee.

Given the variance in fees, and the fact that the transaction may be spent in the future, it's a good idea for the fee payer to keep a good margin, say 5x the expected fee requirement, but differing methods of fee estimation mean we don't specify an exact value.

Since the fees are currently one-sided (the party which requested the channel creation always pays the fees for the commitment transaction), it is simplest to only allow them to set fee levels, but as the same fee rate applies to HTLC transactions, the receiving node must also care about the reasonableness of the fee.

== Message Retransmission ==

Because communication transports are unreliable and may need to be re-established from time to time, the design of the transport has been explicitly separated from the protocol.

Nonetheless, we assume that our transport is ordered and reliable; reconnection introduces doubt as to what has been received, so we retransmit any channel messages which may not have been.

This is fairly straightforward in the case of channel establishment and close where messages have an explicit order, but in normal operation acknowledgments of updates are delayed until the <code>commitment_signed</code> / <code>revoke_and_ack</code> exchange, so we cannot assume the updates have been received. This also means that the receiving node only needs to store updates upon receipt of <code>commitment_signed</code>.

Note that messages described in [[bip-0207.mediawiki|BOLT #7]] are independent of particular channels; their transmission requirements are covered there, and other than being transmitted after <code>init</code> (like any message), they are independent of requirements here.

=== Requirements ===

A node MUST handle continuing a previous channel on a new encrypted transport.

On disconnection, the funder MUST remember the channel for reconnection if it has broadcast the funding transaction, otherwise it MUST NOT.

On disconnection, the non-funding node MUST remember the channel for reconnection if it has sent the <code>funding_signed</code> message, otherwise it MUST NOT.

On disconnection, a node MUST reverse any uncommitted updates sent by the other side (ie. all messages beginning with <code>update_</code> for which no <code>commitment_signed</code> has been received). Note that a node MAY have already use the <code>payment_preimage</code> value from the <code>update_fulfill_htlc</code>, so the effects of <code>update_fulfill_htlc</code> is not completely reversed.

On reconnection, if a channel is in an error state, the node SHOULD retransmit the error packet and ignore any other packets for that channel, or if the channel has entered closing negotiation, the node MUST retransmit the last <code>closing_signed</code>.

Otherwise, on reconnection, a node MUST retransmit old messages after <code>funding_signed</code> which may not have been received, and MUST NOT retransmit old messages which have been explicitly or implicitly acknowledged. The following table lists the acknowledgment conditions for each message:

* <code>funding_locked</code>: acknowledged by <code>update_</code> messages, <code>commitment_signed</code>, <code>revoke_and_ack</code> or <code>shutdown</code> messages.
* <code>update_</code> messages: acknowledged by <code>revoke_and_ack</code>.
* <code>commitment_signed</code>: acknowledged by <code>revoke_and_ack</code>.
* <code>revoke_and_ack</code>: acknowledged by <code>commitment_signed</code> or <code>closing_signed</code>
* <code>shutdown</code>: acknowledged by <code>closing_signed</code>.

Before retransmitting <code>commitment_signed</code>, the node MUST send appropriate <code>update_</code> messages (the other node will have forgotten them, as required above).

A node MAY simply retransmit messages which are identical to the previous transmission. A node MUST not assume that previously-transmitted messages were lost: in particular, if it has sent a previous <code>commitment_signed</code> message, a node MUST handle the case where the corresponding commitment transaction is broadcast by the other side at any time. This is particularly important if a node does not simply retransmit the exact same <code>update_</code> messages as previously sent.

A receiving node MAY ignore spurious message retransmission, or MAY fail the channel if they occur.

=== Rationale ===

The effect of requirements above are that the opening phase is almost atomic: if it doesn't complete, it starts again. The only exception is where the <code>funding_signed</code> message is sent and not received: in this case, the funder will forget the channel and presumably open a new one on reconnect; the other node will eventually forget the original channel due to never receiving <code>funding_locked</code> or seeing the funding transaction on-chain.

There's no acknowledgment for <code>error</code>, so if a reconnect occurs it's polite to retransmit before disconnecting again, but it's not a MUST because there are also occasions where a node can simply forget the channel altogether.

There is similarly no acknowledgment for <code>closing_signed</code>, so it is also retransmitted on reconnection.

= Authors =

FIXME

[[File:https://i.creativecommons.org/l/by/4.0/88x31.png|License CC-BY]] <br> This work is licensed under a [http://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution 4.0 International License].

