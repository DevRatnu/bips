<pre>
  BIP: 207
  Title: BOLT 7: P2P Node and Channel Discovery
  Author: Christian Decker <decker.christian@gmail.com>
          Rusty Russell <rusty@rustcorp.com.au>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0207
  Status: Draft
  Type: Standards Track
  Created: 2016-11-21
  License: CC-BY-4.0
</pre>

This specification describes simple node discovery, channel discovery and channel update mechanisms which do not rely on a third-party to disseminate the information.

Node and channel discovery serve two different purposes:

* Channel discovery allows the creation and maintenance of a local view of the network's topology such that the node can discover routes to the desired destination.
* Node discovery allows nodes to broadcast their ID, host and port, such that other nodes can open connections and establish payment channels.

Peers in the network exchange <code>channel_announcement</code> messages that contain information about new channels between two nodes. They can also exchange <code>node_announcement</code> messages which supply additional information about nodes, and <code>channel_update</code> messages which update information about a channel.

There can only be one valid <code>channel_announcement</code> for any channel, but multiple <code>node_announcement</code> messages are possible (to update node information), and at least two <code>channel_update</code> messages are expected.

== The <code>announcement_signatures</code> message ==

This is a direct message between two endpoints of a channel and serves as an opt-in mechanism to allow the announcement of the channel to the rest of the network. It contains the necessary signatures by the sender to construct the <code>channel_announcement</code> message.

# type: 259 (<code>announcement_signatures</code>)
# data:
#* [<code>32</code>:<code>channel_id</code>]
#* [<code>8</code>:<code>short_channel_id</code>]
#* [<code>64</code>:<code>node_signature</code>]
#* [<code>64</code>:<code>bitcoin_signature</code>]

The willingness of the endpoints to announce the channel is signaled during the connection setup by setting a <code>channels_public</code> bit in the <code>localfeatures</code> field.

=== Requirements ===

If the <code>open_channel</code> message had the <code>announce_channel</code> bit set, then both nodes must send the <code>announcement_signatures</code> message, otherwise they MUST NOT.

If sent, <code>announcement_signatures</code> messages MUST NOT be sent until <code>funding_locked</code> has been sent, and the funding transaction is has at least 6 confirmations.

The <code>short_channel_id</code> is the unique description of the funding transaction. It is constructed with the most significant 3 bytes as the block height, the next 3 bytes indicating the transaction index within the block, and the least significant two bytes indicating the output index which pays to the channel.

The <code>announcement_signatures</code> message is created by constructing a <code>channel_announcement</code> message corresponding to the newly established channel, and sign it with the secrets matching their <code>node_id</code> and <code>bitcoin_key</code>, and send them using an <code>announcement_signatures</code>. The recipient MAY fail the channel if the <code>node_signature</code> or <code>bitcoin_signature</code> is incorrect. The recipient SHOULD queue the <code>channel_announcement</code> message for its peers if it has sent and received a valid <code>announcement_signatures</code> message.

On reconnection, a node SHOULD retransmit the <code>announcement_signatures</code> message if it has not received an <code>announcement_signatures</code> message, and MUST respond to the first <code>announcement_signatures</code> message after reconnection with its own <code>announcement_signatures</code> message.

== The <code>channel_announcement</code> message ==

This message contains ownership information about a channel. It ties each on-chain Bitcoin key to the lightning node key, and vice-versa. The channel is not really usable until at least one side has announced its fee levels and expiry using <code>channel_update</code>.

In order to prove the existence of channel between <code>node_1</code> and <code>node_2</code> we need to:

# Prove that the funding transaction pays to <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code>.
# Prove <code>node_1</code> owns <code>bitcoin_key_1</code>
# Prove <code>node_2</code> owns <code>bitcoin_key_2</code>

The first one is done by assuming that all nodes know the unspent transaction outputs, and thus can find the output given by <code>short_channel_id</code> and validate that it is indeed a P2WSH funding transaction output as to those keys specified in [[bip-0203.mediawiki#funding-transaction-output|BOLT #3]].

The second two are done by explicit signatures (<code>bitcoin_signature_1</code> and <code>bitcoin_signature_2</code>, generated by each <code>bitcoin_key</code> and signing the corresponding <code>node_id</code>.

We also need to prove that <code>node_1</code> and <code>node_2</code> both agree on this announcement message; that is done by having a signature from each <code>node_id</code> signing the message (<code>node_signature_1</code> and <code>node_signature_2</code>).

# type: 256 (<code>channel_announcement</code>)
# data:
#* [<code>64</code>:<code>node_signature_1</code>]
#* [<code>64</code>:<code>node_signature_2</code>]
#* [<code>64</code>:<code>bitcoin_signature_1</code>]
#* [<code>64</code>:<code>bitcoin_signature_2</code>]
#* [<code>8</code>:<code>short_channel_id</code>]
#* [<code>33</code>:<code>node_id_1</code>]
#* [<code>33</code>:<code>node_id_2</code>]
#* [<code>33</code>:<code>bitcoin_key_1</code>]
#* [<code>33</code>:<code>bitcoin_key_2</code>]
#* [<code>2</code>:<code>len</code>]
#* [<code>len</code>:<code>features</code>]

=== Requirements ===

The creating node MUST set <code>short_channel_id</code> to refer to the confirmed funding transaction as specified in [[bip-0202.mediawiki#the-funding_locked-message|BOLT #2]]. The corresponding output MUST be a P2WSH as described in [[bip-0203.mediawiki#funding-transaction-output|BOLT #3]].

The creating node MUST set <code>node_id_1</code> and <code>node_id_2</code> to the public keys of the two nodes who are operating the channel, such that <code>node_id_1</code> is the numerically-lesser of the two DER encoded keys sorted in ascending numerical order, and MUST set <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code> to <code>funding_pubkey</code>s of <code>node_id_1</code> and <code>node_id_2</code> respectively.

The creating node MUST compute the double-SHA256 hash <code>h</code> of the message, starting at offset 256, up to the end of the message. Thus the hash skips the 4 signatures, but hashes the rest of the message, including any future fields appended to the end. <code>node_signature_1</code> and <code>node_signature_2</code> MUST be valid signatures of the hash <code>h</code> using the secret associated with <code>node_id_1</code> and <code>node_id_2</code> respectively. <code>bitcoin_signature_1</code> and <code>bitcoin_signature_2</code> MUST be valid signatures of the hash <code>h</code> using the secret associated with <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code> respectively.

The creating node SHOULD set <code>len</code> to the minimum length required to hold the <code>features</code> bits it sets.

The receiving node MUST ignore the message if the output specified by <code>short_channel_id</code> does not correspond to a P2WSH using <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code> as specified in [[bip-0203.mediawiki#funding-transaction-output|BOLT #3]]. The receiving node MUST ignore the message if this output is spent.

Otherwise, the receiving node SHOULD fail the connection if <code>bitcoin_signature_1</code>, <code>bitcoin_signature_2</code>, <code>node_signature_1</code> or <code>node_signature_2</code> are invalid or not correct.

Otherwise, if <code>node_id_1</code> or <code>node_id_2</code> are blacklisted, it SHOULD ignore the message.

Otherwise, if the transaction referred to was not previously announced as a channel, the receiving node SHOULD queue the message for rebroadcasting, but MAY choose not to for messages longer than the minimum expected length. If it has previously received a valid <code>channel_announcement</code> for the same transaction in the same block, but different <code>node_id_1</code> or <code>node_id_2</code>, it SHOULD blacklist the previous message's <code>node_id_1</code> and <code>node_id_2</code> as well as this <code>node_id_1</code> and <code>node_id_2</code> and forget channels connected to them, otherwise it SHOULD store this <code>channel_announcement</code>.

The receiving node SHOULD NOT route through a channel which has an unknown <code>features</code> bit set which is even.

The receiving node SHOULD forget a channel once its funding output has been spent or reorganized out.

=== Rationale ===

Requiring both nodes to sign indicates they are both willing to route other payments via this node (ie. take part of the public network). Requiring the Bitcoin signatures proves they control the channel.

The blacklisting of conflicting nodes means that we disallow multiple different announcements: no node should ever do this, as it implies that keys have leaked.

While channels shouldn't be advertised before they are sufficiently deep, the requirement against rebroadcasting only applies if the transaction hasn't moved to a different block.

To avoid having to store excessive-sized messages, yet allow reasonable expansion in future, nodes are allowed to restrict rebroadcasting (perhaps statistically).

New channel features are possible in future; backwards compatible (or optional) ones will have odd feature bits, incompatible ones will have even feature bits ([[bip-0200.mediawiki#glossary-and-terminology-guide|&quot;It's OK to be odd!&quot;]]. These will be propagated by nodes even if they can't use the announcements themselves.

== The <code>node_announcement</code> message ==

This allows a node to indicate extra data associated with it, in addition to its public key. To avoid trivial denial of service attacks, nodes for which a channel is not already known are ignored.

# type: 257 (<code>node_announcement</code>)
# data:

* [<code>64</code>:<code>signature</code>]
* [<code>4</code>:<code>timestamp</code>]
* [<code>33</code>:<code>node_id</code>]
* [<code>3</code>:<code>rgb_color</code>]
* [<code>32</code>:<code>alias</code>]
* [<code>2</code>:<code>flen</code>]
* [<code>flen</code>:<code>features</code>]
* [<code>2</code>:<code>addrlen</code>]
* [<code>addrlen</code>:<code>addresses</code>]

The <code>timestamp</code> allows ordering in the case of multiple announcements; the <code>rgb_color</code> and <code>alias</code> allow intelligence services to give their nodes cool monikers like IRATEMONK and WISTFULTOLL and use the color black.

<code>addresses</code> allows the node to announce its willingness to accept incoming network connections: it contains series of <code>address descriptor</code>s for connecting to the node. The first byte describes the address type, followed by the appropriate number of bytes for that type.

The following <code>address descriptor</code> types are defined:

* <code>0</code>: padding. data = none (length 0).
* <code>1</code>: ipv4. data = <code>[4:ipv4_addr][2:port]</code> (length 6)
* <code>2</code>: ipv6. data = <code>[16:ipv6_addr][2:port]</code> (length 18)
* <code>3</code>: tor v2 onion service. data = <code>[10:onion_addr][2:port]</code> (length 12)
** Version 2 onion service addresses. Encodes an 80-bit truncated <code>SHA-1</code> hash of a 1024-bit <code>RSA</code> public key for the onion service.
* <code>4</code>: tor v3 onion service. data <code>[35:onion_addr][2:port]</code> (length 37)
** Version 3 ([https://gitweb.torproject.org/torspec.git/tree/proposals/224-rend-spec-ng.txt prop224]) onion service addresses. Encodes: <code>[32:32_byte_ed25519_pubkey] || [2:checksum] || [1:version]</code>. where <code>checksum = sha3(&quot;.onion checksum&quot; | pubkey || version)[:2]</code>

=== Requirements ===

The creating node MUST set <code>timestamp</code> to be greater than any previous <code>node_announcement</code> it has created. It MAY base it on a UNIX timestamp. It MUST set <code>signature</code> to the signature of the double-SHA256 of the entire remaining packet after <code>signature</code> using the key given by <code>node_id</code>. It MAY set <code>alias</code> and <code>rgb_color</code> to customize their node's appearance in maps and graphs, where the first byte of <code>rgb</code> is the red value, the second byte is the green value and the last byte is the blue value. It MUST set <code>alias</code> to a valid UTF-8 string, with any <code>alias</code> bytes following equal to zero.

The creating node SHOULD fill <code>addresses</code> with an address descriptor for each public network address which expects incoming connections, and MUST set <code>addrlen</code> to the number of bytes in <code>addresses</code>. Non-zero typed address descriptors MUST be placed in ascending order; any number of zero-typed address descriptors MAY be placed anywhere, but SHOULD only be used for aligning fields following <code>addresses</code>.

The creating node MUST NOT create a type 1 or type 2 address descriptor with <code>port</code> equal to zero, and SHOULD ensure <code>ipv4_addr</code> and <code>ipv6_addr</code> are routable addresses. The creating node MUST NOT include more than one <code>address descriptor</code> of the same type.

The creating node SHOULD set <code>flen</code> to the minimum length required to hold the <code>features</code> bits it sets.

The receiving node SHOULD fail the connection if <code>node_id</code> is not a valid compressed public key, and MUST NOT further process the message.

The receiving node SHOULD fail the connection if <code>signature</code> is not a valid signature using <code>node_id</code> of the double-SHA256 of the entire message following the <code>signature</code> field (including unknown fields following <code>alias</code>), and MUST NOT further process the message.

The receiving node SHOULD ignore the first <code>address descriptor</code> which does not match the types defined above. The receiving node SHOULD fail the connection if <code>addrlen</code> is insufficient to hold the address descriptors of the known types.

The receiving node SHOULD ignore <code>ipv6_addr</code> or <code>ipv4_addr</code> if <code>port</code> is zero.

The receiving node SHOULD ignore the message if <code>node_id</code> is not previously known from a <code>channel_announcement</code> message, or if <code>timestamp</code> is not greater than the last-received <code>node_announcement</code> from this <code>node_id</code>. Otherwise, if the <code>timestamp</code> is greater than the last-received <code>node_announcement</code> from this <code>node_id</code> the receiving node SHOULD queue the message for rebroadcasting, but MAY choose not to for messages longer than the minimum expected length.

The receiving node SHOULD NOT connect to a node which has an unknown <code>features</code> bit set in the <code>node_announcement</code> which is even.

The receiving node MAY use <code>rgb_color</code> and <code>alias</code> to reference nodes in interfaces, but SHOULD insinuate their self-signed origin.

=== Rationale ===

New node features are possible in future; backwards compatible (or optional) ones will have odd feature bits, incompatible ones will have even feature bits. These will be propagated by nodes even if they can't use the announcements themselves.

New address types can be added in future; as address descriptors have to be ordered in ascending order so they will be safely ignored. Future fields beyond <code>addresses</code> can still be added, optionally with padding within <code>addresses</code> if they require certain alignment.

== The <code>channel_update</code> message ==

After a channel has been initially announced, each side independently announces its fees and minimum expiry for HTLCs. It uses the 8-byte channel shortid which matches the <code>channel_announcement</code> and one bit in the <code>flags</code> field to indicate which end this is. It can do this multiple times, if it wants to change fees.

# type: 258 (<code>channel_update</code>)
# data:
#* [<code>64</code>:<code>signature</code>]
#* [<code>8</code>:<code>short_channel_id</code>]
#* [<code>4</code>:<code>timestamp</code>]
#* [<code>2</code>:<code>flags</code>]
#* [<code>2</code>:<code>cltv_expiry_delta</code>]
#* [<code>8</code>:<code>htlc_minimum_msat</code>]
#* [<code>4</code>:<code>fee_base_msat</code>]
#* [<code>4</code>:<code>fee_proportional_millionths</code>]

The <code>flags</code> bitfield is used to indicate the direction of the channel this update concerns, i.e., it identifies the node that this update originated from, and signal various options concerning the channel. The following table specifies the meaning of the individual bits:

{|
!Bit Position
!Name
!Meaning
|-
|0
|<code>direction</code>
|Direction this update refers to.
|-
|1
|<code>disable</code>
|Disable the channel.
|}

=== Requirements ===

The creating node MUST set <code>signature</code> to the signature of the double-SHA256 of the entire remaining packet after <code>signature</code> using its own <code>node_id</code>.

The creating node MUST set <code>short_channel_id</code> to match those in the already-sent <code>channel_announcement</code> message, and MUST set the <code>direction</code> bit of <code>flags</code> to 0 if the creating node is <code>node_id_1</code> in that message, otherwise 1. Bits which are not assigned a meaning must be set to 0.

A node MAY create and send a <code>channel_update</code> with the <code>disable</code> bit set to signal the temporary unavailability of a channel, e.g., due to loss of connectivity, or the permanent unavailability, e.g., ahead of an on-chain settlement. A subsequent <code>channel_update</code> with the <code>disable</code> bit unset MAY re-enable the channel.

The creating node MUST set <code>timestamp</code> to greater than zero, and MUST set it to greater than any previously-sent <code>channel_update</code> for this <code>short_channel_id</code>.

It MUST set <code>cltv_expiry_delta</code> to the number of blocks it will subtract from an incoming HTLCs <code>cltv_expiry</code>. It MUST set <code>htlc_minimum_msat</code> to the minimum HTLC value it will accept, in millisatoshi. It MUST set <code>fee_base_msat</code> to the base fee it will charge for any HTLC, in millisatoshi, and <code>fee_proportional_millionths</code> to the amount it will charge per millionth of a satoshi.

The receiving node MUST ignore <code>flags</code> other than the least significant bit. It SHOULD ignore the message if <code>short_channel_id</code> does not correspond to a previously known, unspent channel from <code>channel_announcement</code>, otherwise the <code>node_id</code> is taken from the <code>channel_announcement</code>: <code>node_id_1</code> if least-significant bit of flags is 0 or <code>node_id_2</code> otherwise. The receiving node SHOULD fail the connection if <code>signature</code> is not a valid signature using <code>node_id</code> of the double-SHA256 of the entire message following the <code>signature</code> field (including unknown fields following <code>fee_proportional_millionths</code>), and MUST NOT further process the message.

The receiving node SHOULD ignore the message if <code>timestamp</code> is not greater than than the last-received <code>channel_announcement</code> for this <code>short_channel_id</code> and <code>node_id</code>. Otherwise, if the <code>timestamp</code> is equal to the last-received <code>channel_announcement</code> and the fields other than <code>signature</code> differ, the node MAY blacklist this <code>node_id</code> and forget all channels associated with it. Otherwise the receiving node SHOULD queue the message for rebroadcasting, but MAY choose not to for messages longer than the minimum expected length.

== Initial Sync ==

Upon establishing a connection, the two endpoints negotiate whether to perform an initial sync by setting the <code>initial_routing_sync</code> flags in the <code>init</code> message. The endpoint SHOULD set the <code>initial_routing_sync</code> flag if it requires a full copy of the other endpoint's routing state. Upon receiving an <code>init</code> message with the <code>initial_routing_sync</code> flag set the node sends <code>channel_announcement</code>s, <code>channel_update</code>s and <code>node_announcement</code>s for all known channels and nodes as if they were just received.

If the <code>initial_routing_sync</code> flag is not set, or initial sync was completed, then the node resumes normal operation, see the ''Rebroadcasting'' section for details.

== Rebroadcasting ==

Nodes receiving a new <code>channel_announcement</code> or a <code>channel_update</code> or <code>node_announcement</code> with an updated timestamp update their local view of the network's topology accordingly.

Once the announcement has been processed it is added to a list of outgoing announcements (perhaps replacing older updates) to the processing node's peers, which will be flushed at regular intervals. This store and delayed forward broadcast is called a ''staggered broadcast''

If, after applying the changes from the announcement, there are no channels associated with the announcing node, then the receiving node MAY purge the announcing node from the set of known nodes. Otherwise the receiving node updates the metadata and stores the signature associated with the announcement. This will later allow the receiving node to rebuild the announcement for its peers.

After processing the announcement the receiving node adds the announcement to a list of outgoing announcements.

=== Requirements ===

Each node SHOULD flush outgoing announcements once every 60 seconds, independently of the arrival times of announcements, resulting in a staggered announcement and deduplication of announcements.

Nodes MAY re-announce their channels regularly, however this is discouraged in order to keep the resource requirements low.

Nodes SHOULD send all <code>channel_announcement</code> messages followed by the latest <code>node_announcement</code> and <code>channel_update</code> messages upon connection establishment.

=== Rationale ===

Batching announcements form a natural ratelimit with low overhead.

The sending of all announcements on reconnection is naive, but simple, and allows bootstrap for new nodes as well as updating for nodes which have been offline for some time.

== HTLC Fees ==

The node creating <code>channel_update</code> SHOULD accept HTLCs which pay a fee equal or greater than:

<pre>fee_base_msat + amount_msat * fee_proportional_millionths / 1000000</pre>
The node creating <code>channel_update</code> SHOULD accept HTLCs which pay an older fee for some time after sending <code>channel_update</code> to allow for propagation delay.

== Recommendations for Routing ==

As the fee is proportional, it must be calculated backwards from the destination to the source: only the amount required at the final destination is known initially.

When calculating a route for an HTLC, the <code>cltv_expiry_delta</code> and the fee both need to be considered: the <code>cltv_expiry_delta</code> contributes to the time that funds will be unavailable on worst-case failure. The tradeoff between these two is unclear, as it depends on the reliability of nodes.

Other more advanced considerations involve diversity of routes to avoid single points of failure and detection, and channel balance of local channels.

== References ==

[[File:https://i.creativecommons.org/l/by/4.0/88x31.png|License CC-BY]] <br> This work is licensed under a [http://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution 4.0 International License].

